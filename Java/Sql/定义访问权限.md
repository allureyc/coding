# GRANT定义访问权限

## Name

GRANT -- 定义访问权限

## Synopsis

```sql
GRANT { { SELECT | INSERT | UPDATE | DELETE | RULE | REFERENCES | TRIGGER }[ ,...] | ALL [ PRIVILEGES ] } ON [ TABLE ] tablename [. ...] To {username | GROuP groupname | PUBLIC } [，...][ wITH GRANT OPTION ]

GRANT { { CREATE | TEMPORARY| TEMP}[,...] | ALL [ PRIVILEGES ] } ON DATABASE dbname [， ...]To { username | GROUP groupname | PUBLIC } [，...] [ WITH GRANT OPTION ]

GRANT { EXECUTE | ALL [ PRIVILEGES ] } ON FUNCTION funcname ( [ [ argmode ] [ argname ] argtype [，...] ] ) [，...] To { username | GROUP groupname | PUBLIC } [，...] [ wITH GRANT OPTION ]

GRANT { USAGE | ALL [ PRIVILEGES ] } ON LANGUAGE langname [. ...] To { username | GROUP groupname | PUBLIC } [，...] [ WITH GRANT OPTION ]

GRANT { { CREATE / USAGE } [....] l ALL [ PRIVILEGES ] } ON SCHEMA schemaname [, ...] To { username | GROUP groupname | PUBLIC } [，...] [ WITH GRANT OPTION ]

GRANT { CREATE | ALL [ PRIVILEGES ] } ON TABLESPACE tablespacename [. ...] To {username | GROUP groupname | PUBLIC } [，...][ WITH GRANT OPTION ]
```

## 例子

把表fi1ms 的插入权限赋予所有用户:

```sql
GRANT INSERT ON films TO PUBLIC;
```

赋予用户manue1对视图kinds的所有权限:

```sql
GRANT ALL PRIVILEGES ON kinds TO manuel;
```

请注意，如果上面的命令由超级用户或者kindis的所有者执行，那么它实际上会赋予所有权限，如果由其他人执行，那么它会赋予这个“其他人"拥有授权选项的所有权限。

设置访问权限
语法格式如下:

```sql
GRANT permission_type ON table_name TO role_name;
```

实例:

```sql
GRANT UPDATE ON demo TO demo_role; --赋予demo_role demo表的update权限
GRANT SELECT ON ALL TABLES IN SCHEMA PUBLIC to demo_role; --赋予demo_role所有表的SELECT权限
```

特殊符号:ALL代表所访问权限，PUBLIC代表所有用户

```sql
GRANT ALL ON demo TO demo_role; --赋给用户所有权限
GRANT SELECT ON demo TO PUBLIC; --将SELECT权限赋给所有用户
```

\z或\dp指令显示用户访问权限。
\h GRANT显示所有可设置的访问权限

## 撤销用户访问权限

- 语法格式如下:

```sql
REVOKE permission_type ON table_name FROM user_name;
```

其中`permission_type`和`table_name`含义与`GRANT`指令中相同。

## 用户组

在postgres中用户实际上是role，同时组也是role。 包含其他role的role就是组。

创建组示例:

```sql
CREATE ROLE temporary_users;
GRANT temporary_users TO demo_role;
GRANT temporary_users TO test_user;
```

切换ROLE

```sql
SET ROLE role_name; --切换到role_name用户
RESET ROLE; --切换回最初的role
```

INHERIT权限：该属性使组成员拥有组的所有权限

```sql
ALTER ROLE test_user INHERIT;
```

删除用户和组
删除用户和组很简单:

```sql
DROP ROLE role_name;
DROP ROLE IF EXISTS role_name;
```

删除组role只会删除组的role本身，组的成员并不会被删除。

## 描述

`GRANT` 命令将某对象（表，视图，序列，函数，过程语言，模式或者表空间） 上的特定权限给予一个用户或者多个用户或者一组用户。 这些权限将增加到那些已经赋予的权限上，如果存在这些权限的话。

键字 `PUBLIC` 表示该权限要赋予所有用户, 包括那些以后可能创建的用户。`PUBLIC` 可以看做是一个隐含定义好的组，它总是包括所有用户。 任何特定的用户都将拥有直接赋予他/她的权限，加上他/她所处的任何组， 以及再加上赋予 `PUBLIC` 的权限的总和。

如果声明了 `WITH GRANT OPTION`，那么权限的受予者也可以赋予别人。 没有这个选项，接受权限的用户不能给别人授权不允许的。 目前，赋权选项只能给独立的用户，而不能给组或者 `PUBLIC`。

对对象的所有者（通常就是创建者）而言，没有什么权限需要赋予， 因为所有者缺省就持有所有权限。（不过，所有者出于安全考虑可以选择废弃一些他自己的权限。） 删除一个对象的权力，或者是任意修改它的权力都不是可赋予的权利所能描述的； 它是创建者固有的，并且不能赋予或撤销。所有者也隐含地拥有该对象的所有授权选项。

根据对象的不同，初始的缺省权限可能包括给 `PUBLIC` 赋予一些权限。缺省设置对于表，模式和表空间是没有公开访问权限的； `TEMP` 表为数据库创建权限；`EXECUTE` 权限用于函数； 以及 `USAGE` 用于语言。对象所有者当然可以撤回这些权限。 （出于最大安全性考虑，在创建该对象的同一个事务中发出 `REVOKE`； 那么就不会打开给别的用户使用该对象的窗口。）

可能的权限有：

- SELECT

- 允许对声明的表，试图，或者序列 [*SELECT*](http://www.php100.com/manual/PostgreSQL8/sql-select.html) 任意字段。还允许做 [*COPY*](http://www.php100.com/manual/PostgreSQL8/sql-copy.html) TO 的源。 对于序列而言，这个权限还允许使用 `currval` 函数。

- INSERT

- 允许向声明的表 [INSERT](http://www.php100.com/manual/PostgreSQL8/sql-insert.html) 一个新行。 同时还允许做 [COPY](http://www.php100.com/manual/PostgreSQL8/sql-copy.html) FROM。

- UPDATE

- 允许对声明的表中任意字段做  [UPDATE](http://www.php100.com/manual/PostgreSQL8/sql-update.html)。 `SELECT ... FOR UPDATE` 和 `SELECT ... FOR SHARE` 也要求这个权限（除了 `SELECT` 权限之外）。比如， 这个权限允许使用`nextval`， 和 `setval`。

- DELETE

- 允许从声明的表中 [*DELETE*](http://www.php100.com/manual/PostgreSQL8/sql-delete.html) 行。

- RULE

- 允许在该表/视图上创建规则。（参阅 [*CREATE RULE*](http://www.php100.com/manual/PostgreSQL8/sql-createrule.html) 语句。）

- REFERENCES

- 要创建一个外键约束，你必须在参考表和被参考表上都拥有这个权限。

- TRIGGER

- 允许在声明表上创建触发器。（参阅 [*CREATE TRIGGER*](http://www.php100.com/manual/PostgreSQL8/sql-createtrigger.html) 语句。）

- CREATE

- 对于数据库，允许在该数据库里创建新的模式。

  对于模式，允许在该模式中创建新的对象。 要重命名一个现有对象，你必需拥有该对象*并且*。 对包含该对象的模式拥有这个权限。

  对于表空间，允许表在该表空间中创建，以及允许创建数据库和模式的时候把该表空间指定为其缺省表空间。    （请注意，撤销这个权限不会改变现有数据库和模式的存放位置。）

- TEMPORARY
  TEMP

- 允许在使用该数据库的时候创建临时表。

- EXECUTE

- 允许使用指定的函数并且可以使用任何利用这些函数实现的操作符。 这是适用于函数的唯一的一种权限类型。 （该语法同样适用于聚集函数。）

- USAGE

- 对于过程语言， 允许使用指定过程语言创建该语言的函数。 这是适用于过程语言的唯一的一种权限类型。

  对于模式，允许访问包含在指定模式中的对象（假设该对象的所有权要求同样也设置了）。 最终这些就允许了权限接受者"查询"模式中的对象。

- ALL PRIVILEGES

- 一次性给予所有可以赋予的权限。 `PRIVILEGES` 关键字在 PostgreSQL 里是可选的， 但是严格的 SQL 要求有这个关键字。

其它命令要求的权限都在相应的命令的参考页上列出。

## 注意

[*REVOKE*](http://www.php100.com/manual/PostgreSQL8/sql-revoke.html) 命令用于删除访问权限。

如果非对象所有者企图在对象上 `GRANT` 权限，而该用户没有该对象上指定的权限，那么命令将立即失败。   只要有某些可用的权限，该命令就会继续，但是它只授予那些该用户有授权选项的权限。   如果手头没有可用的授权选项，那么 `GRANT ALL PRIVILEGES` 形式将发出一个警告信息，   其它命令形式将发出在命令中提到的，但是没有授权选项的那些权限相关的警告信息。   （这些语句原则上也适用于对象所有者，但是因为所有者总是被认为拥有所有授权选项，所以这种情况永远不会发生在所有者身上。）

我们要注意数据库超级用户可以访问所有对象， 而不会受对象的权限设置影响。这个特点类似 Unix 系统的 `root` 的权限。和 `root` 一样，除了必要的情况，总是以超级用户身分进行操作是不明智的做法。

目前，PostgreSQL 不支持给一个表的独立字段进行权限赋予和撤销的操作， 一个绕开的办法是创建一个拥有那几行的视图然后给那个视图赋予权限。

使用 [psql](http://www.php100.com/manual/PostgreSQL8/app-psql.html) 的 `\z` 命令获取在现有对象上的与权限有关的信息。

